# argparse

cmd창에서 명령을 줄 때, argument를 받을 수 있게하는 명령어이다.

https://greeksharifa.github.io/references/2019/02/12/argparse-usage/

```
import argparse

parser = argparse.ArgumentParser(description='Argparse Tutorial')
# argument는 원하는 만큼 추가한다.
parser.add_argument('--print-number', type=int, 
                    help='an integer for printing repeatably')

args = parser.parse_args()

for i in range(args.print_number):
    print('print number {}'.format(i+1))
```

```
> python argparseTest.py -h
usage: argparseTest.py [-h] [--print-number PRINT_NUMBER]

Argparse Tutorial

optional arguments:
  -h, --help            show this help message and exit
  --print-number PRINT_NUMBER
                        an integer for printing repeatably

> python argparseTest.py --print-number 5
print number 1
print number 2
print number 3
print number 4
print number 5
```

# __enter__() , __exit__()

https://sjquant.tistory.com/12

클래스에서 with구문을 적극적으로 사용하기 위해서는 클래스에 __enter__과 __exit__이라는 Magic Methods를 정의해주면 됩니다.

다음은 예시이다.

```
from sqlalchemy import create_engine
from sqlalchemy.orm import sessionmaker

class SQLAlchemyDBConnection(object):
    """SQLAlchemy database connection"""
    def __init__(self, connection_string):
        self.connection_string = connection_string
        self.session = None

    # with구문 진입시에 db와 connection을 하고
    # ORM을 사용하기 위한 session을 만들어준다.
    def __enter__(self):
        engine = create_engine(self.connection_string)
        Session = sessionmaker()
        self.session = Session(bind=engine)
        return self

    # with구문을 빠져나오기 전 session의 종료를 장한다.
    def __exit__(self, exc_type, exc_val, exc_tb):
        self.session.close()
```

다음과 같이 with와 함께 사용할 수 있다.

```
conn_str = 'mssql+pydobc://server_name/db_name?driver=SQL+Server'
db = SQLAlchemyDBConnection(conn_str)
with db:
    customer = db.session.query(Customer).filter_by(id=123).one()
    print(customer.name)
```

enter는 with 구문 시작할 때, exit은 with 구문 탈출할 때 사용된다.

# rospy.init_node()

node 생성. node name을 인자로 받음

http://wiki.ros.org/rospy/Overview/Initialization%20and%20Shutdown


# staticmethod

https://dojang.io/mod/page/view.php?id=2379

기본적으로 객체에서는 사용할 수 없고 클래스에서만 사용할 수 있는 메서드를 정적메서드라고 한다.

self를 받지 않아서, 객체에는 접근이 불가능하다.
정적 메서드는 인스턴스의 상태를 변화시키지 않는 메서드를 만들 때 사용한다.

```
class 클래스이름:
    @staticmethod
    def 메서드(매개변수1, 매개변수2):
        코드
```



# __ 으로 시작하는 method

__(밑줄 두 개)로 시작하면 클래스 안에서만 호출할 수 있는 비공개 메서드가 된다.

# __getitem__() 메서드

__init__()과 마찬가지로 파이썬 내장 메서드이다.

__init__은 클래스를 생성할 때 실행되는 생성자이다.
__getitem__은 클래스의 인덱스에 접근할 때 자동으로 호출되는 메서드이다.


 __getitem__은 슬라이싱을 구현할 수 있도록 도우며 리스트에서 슬라이싱을 하게되면 내부적으로 __getitem__ 메소드를 실행한다는 점이 중요하다. 따라서 객체에서도 슬라이싱을 하기 위해서는 __getitem__ 메소드가 필수적이다.

 인스턴스 변수에 직접 접근하지 말고 객체 자체를 통해서 슬라이싱을 구현하기 위해서는 **getitem 특별 메소드를 정의해야한다.


```
class CustomNumbers:
  def __init__(self):
    self._numbers = [n for n in range(1, 11)]

  def __getitem__(self, idx):
    return self._numbers[idx]

a = CustomNumbers()
a[2:7]
# [3, 4, 5, 6, 7]
```

# Method Overiding

https://dojang.io/mod/page/view.php?id=2387

```
class Person:
    def greeting(self):
        print('안녕하세요.')
 
class Student(Person):
    def greeting(self):
        print('안녕하세요. 저는 파이썬 코딩 도장 학생입니다.')
 
james = Student()
james.greeting()

안녕하세요. 저는 파이썬 코딩 도장 학생입니다.
```

super를 통해서 상속받은 메서드를 사용할 수도 있다.
```
class Person:
    def greeting(self):
        print('안녕하세요.')
 
class Student(Person):
    def greeting(self):
        super().greeting()    # 기반 클래스의 메서드 호출하여 중복을 줄임
        print('저는 파이썬 코딩 도장 학생입니다.')
 
james = Student()
james.greeting()

안녕하세요.
저는 파이썬 코딩 도장 학생입니다.
```

# 상속 클래스 사용하기 : super()

https://velog.io/@gwkoo/%ED%81%B4%EB%9E%98%EC%8A%A4-%EC%83%81%EC%86%8D-%EB%B0%8F-super-%ED%95%A8%EC%88%98%EC%9D%98-%EC%97%AD%ED%95%A0

다음 두 가지 방법으로 사용할 수 있다.

```
class Person:
    def __init__(self):
        print('Person __init__')
        self.hello = '안녕하세요.'
 
class Student(Person):
    def __init__(self):
        print('Student __init__')
        super().__init__()                # super()로 기반 클래스의 __init__ 메서드 호출
        self.school = '파이썬 코딩 도장'
 
james = Student()
print(james.school)
print(james.hello)
```

아래는 python 2 version
```
class Student(Person):
    def __init__(self):
        print('Student __init__')
        super(Student, self).__init__()     # super(파생클래스, self)로 기반 클래스의 메서드 호출
        self.school = '파이썬 코딩 도장'
```


# glob File I/O

https://wikidocs.net/83

https://engineer-mole.tistory.com/188

# self.__class__

상속받는 경우, 현재 클래스에 대해서 참조를 하기 위해서 사용한다.

클래스 이름 참조하기
```
클래스명.__name__                       // 클래스이름을 참조한다
또는
클래스 내부에서 self.__class__.__name__  // 클래스이름을 참조한다
```

2) 클래스 변수 참조하기
```
클래스명.변수명                         // 지정 클래스의 변수를 참조한다
또는
클래스 내부에서 self.__class__.변수명    // 클래스변수를 참조한다
```

```
class Car:
    str_condition = "unknown"
    def __init__(self, str_model):
        self.str_model = str_model
        
    def echo(self):
        print("class name:", self.__class__.__name__) #// 클래스이름을 출력한다
        
        #// print("condition:", Car.str_condition) #// Car클래스변수만을 출력한다
        print("condition:", self.__class__.str_condition) #// 클래스변수를 출력한다
        
        print("model:", self.str_model) #// 인스턴스변수를 출력한다

class NewCar(Car):
    str_condition = "new"

class UsedCar(Car):
    str_condition = "old"
```

# self와 cls의 차이점

클래스 메서드는 첫 번째 매개변수에 cls를 지정해야 합니다(cls는 class에서 따왔습니다).

self, cls의 키워드의 차이점은 오직 매소드 타입에 있습니다. instance 매소드를 사용하면 self 키워드를 사용하고 class 매소드를 사용하면 cls 키워드를 사용합니다. static 매소드는 속성에 접근할 수 없기 때문에 사용하는 키워드가 없습니다.

속성에 접근하기 위한 방법이며 매소드의 종류에 따라 self, cls 키워드를 사용한다고 생각하면 됩니다.

또한, self는 해당 인스턴스를 의미하고, cls는 해당 클래스를 의미하게 되는 것이다.

```
class 클래스이름:
    @classmethod
    def 메서드(cls, 매개변수1, 매개변수2):
        코드
```

```
class Person:
    count = 0    # 클래스 속성
 
    def __init__(self):
        Person.count += 1    # 인스턴스가 만들어질 때
                             # 클래스 속성 count에 1을 더함
 
    @classmethod
    def print_count(cls):
        print('{0}명 생성되었습니다.'.format(cls.count))    # cls로 클래스 속성에 접근

james = Person()
maria = Person()
 
Person.print_count()    # 2명 생성되었습니다.

2명 생성되었습니다.
```

특히 cls를 사용하면 메서드 안에서 현재 클래스의 인스턴스를 만들 수도 있습니다. 즉, cls는 클래스이므로 cls()는 Person()과 같습니다.

```
@classmethod
def create(cls):
    p = cls()    # cls()로 인스턴스 생성
    return p
```

